<?php

include_once('dao.connection.php');
include_once('entity.point.php');
include_once('entity.polygon.php');
include_once('entity.multipolygon.php');
include_once('entity.extent.php');

class MultiPolygonDAO {

    private static $instance;
    private $canvasW = 500;
    private $canvasH = 469.4;
    
    
    public static function getInstance() {
        if (!isset(self::$instance))
            self::$instance = new MultiPolygonDAO();

        return self::$instance;
    }

    /**
     * Cria lista de MultiPolygons filtrados pela região (Norte/Nordeste/Sul/Sudeste/Centro-Oeste)
     * @return MultiPolygon 
     */
    public function listByRegion($region) {

        $sql = "SELECT ST_AsText(g_map) as wkt
                FROM d_geometry
                WHERE g_region='" . $region . "'
                ORDER BY sky_geometry";

        $this->connection = new Connection();
        $result = $this->connection->executeSQL($sql);

        $extent = $this->getExtent(null);

        while ($row = pg_fetch_row($result)) {
            $multipolygon = new MultiPolygon();
            $polygons = $this->convertWKTtoPolygons($row[0], $extent);
            $multipolygon->polygons = $polygons;
            $listamultipolygons[] = $multipolygon;
        }
        return $listamultipolygons;
    }

    /**
     * Recupera lista de MultiPolygons que contém ponto dado
     * @param type $point
     * @param type $extent
     * @return type 
     */
    private function findByPoint($point, $extent) {

        $point = $this->convertCanvasPoint($point, $extent);

        $sPoint = 'POINT(' . $point->x . ' ' . $point->y . ')';

        $sql = "SELECT sky_geometry as id, ST_AsText(g_map) as wkt
            FROM d_geometry 
            WHERE ST_Contains(g_map, GeomFromText('" . $sPoint . "'))";

        $result = $this->connection->executeSQL($sql);

        return $result;
    }

    /**
     * Retorna poligonos que fazem interseção com o extent dado
     * @param type $extent
     * @return type 
     */
    private function findByExtent($extent) {

        $point1 = $extent->pointMin->x . ' ' . $extent->pointMin->y;
        $point2 = $extent->pointMax->x . ' ' . $extent->pointMin->y;
        $point3 = $extent->pointMax->x . ' ' . $extent->pointMax->y;
        $point4 = $extent->pointMin->x . ' ' . $extent->pointMax->y;

        $polygon = 'MULTIPOLYGON(((' . $point1 . ',' . $point4 . ',' . $point3 . ',' . $point2 . ',' . $point1 . ')))';

        $sql = "SELECT sky_geometry as id, ST_AsText(g_map) as wkt
            FROM d_geometry 
            WHERE ST_Intersects(ST_GeomFromText('" . $polygon . "'), g_map)
            AND g_city IS NOT NULL";

        $result = $this->connection->executeSQL($sql);

        return $result;
    }

    /**
     * Retorna extent do mapa
     * @param type $id
     * @return Extent 
     */
    public function getExtent($id) {

        $sql = "SELECT MAX(ST_XMAX(Box2D(ST_GeomFromText(g_map)))) as xmax,
          MAX(ST_YMAX(Box2D(ST_GeomFromText(g_map)))) as ymax,
          MIN(ST_XMIN(Box2D(ST_GeomFromText(g_map)))) as xmin,
          MIN(ST_YMIN(Box2D(ST_GeomFromText(g_map)))) as ymin
          FROM d_geometry";

        if ($id != null) {
            $sql.=" WHERE sky_geometry=" . $id;
        }

        $result = $this->connection->executeSQL($sql);

        while ($row = pg_fetch_row($result)) {
            
            $max = new Point();            
            $max->x = round($row[0], 4);
            $max->y = round($row[1], 4);            
            
            $min = new Point();
            $min->x = round($row[2], 4);
            $min->y = round($row[3], 4);
        }
        $extent = new Extent();
        $extent->pointMax = $max;
        $extent->pointMin = $min;
        
        return $extent;
    }

    /**
     * Converte WKT para lista de Polygons
     * @param type $wkt
     * @param type $extent
     * @return Polygon 
     */
    public function convertWKTtoPolygons($wkt, $extent) {

        //correção para zoom proporcional do município
        $distanceX = abs($extent->pointMax->x - $extent->pointMin->x);
        $distanceY = abs($extent->pointMax->y - $extent->pointMin->y);

        if ($distanceX > $distanceY) {
            $width = $this->canvasW;
            $height = ($distanceY * $width) / $distanceX;
        } else {
            $height = $this->canvasH;
            $width = ($distanceX * $height) / $distanceY;
        }

        $wkt = substr_replace($wkt, "", 0, 15);
        $wkt = substr($wkt, 0, -3);

        $wkt = explode(")),((", $wkt);

        //para cada poligono       
        for ($i = 0; $i < sizeof($wkt); $i++) {

            $wkt = explode(",", $wkt[$i]); //separa os pontos do poligono                
            //para cada ponto do poligono

            for ($j = 0; $j < sizeof($wkt); $j++) {

                $xy = explode(" ", $wkt[$j]); //separa o X e Y do ponto

                $xc = (round($xy[0], 4) - $extent->pointMin->x) / ($extent->pointMax->x - $extent->pointMin->x) * $width;
                $yc = ((round($xy[1], 4) - $extent->pointMin->y) / ($extent->pointMax->y - $extent->pointMin->y) * -$height) + $height;

                $point = new Point();
                $point->x = round($xc, 4);
                $point->y = round($yc, 4);
                $points[] = $point;
            }

            $polygon = new Polygon();
            $polygon->points = $points;
            $polygons[] = $polygon;
        }
        return $polygons;
    }

    /**
     * Retorna poligono que contém o ponto dado
     * @param type $point
     * @param type $extent
     * @return type 
     */
    public function selectByPoint($point, $extent) {
       
        $this->connection = new Connection();
       
        if($extent == null){
            $extent = $this->getExtent(null);
        }        
        $result = $this->findByPoint($point, $extent);

        while ($row = pg_fetch_object($result)) {
            $polygons = $this->convertWKTtoPolygons($row->wkt, $extent);
            $multipolygon->polygons = $polygons;
            $listamultipolygons[] = $multipolygon;
        }
        return $listamultipolygons;
    }

    /**
     * Recupera MultiPolygons que contém ponto dado e maximiza as coordenadas para visualizar no canvas
     * @param type $point
     * @param type $extent
     * @return type 
     */
    public function zoomByPoint($point, $extent) {

        $this->connection = new Connection();
       
        if($extent == null){
            $extent = $this->getExtent(null);
        } 
        
        $result = $this->findByPoint($point, $extent);

        while ($row = pg_fetch_object($result)) {
            $extent = $this->getExtent($row->id);
            $polygons = $this->convertWKTtoPolygons($row->wkt, $extent);
            $multipolygon->polygons = $polygons;
            $listamultipolygons[] = $multipolygon;
        }
        return $listamultipolygons;
    }

    /**
     * Recupera MultiPolygons que estão contidos dentro do extent dado
     * @param type $zoomExtent
     * @param type $extent
     * @return MultiPolygon 
     */
    public function zoomByExtent($zoomExtent, $extent) {
       
        $this->connection = new Connection();
        $extent = $this->convertExtent($zoomExtent, $extent);
        $listamultipolygons[] = $extent;
        $result = $this->findByExtent($extent);
        
        $max = new Point();
        $max->x = $extent->pointMax->x;
        $max->y = $extent->pointMin->y;

        $min = new Point();
        $min->x = $extent->pointMin->x;
        $min->y = $extent->pointMax->y;

        $extentFixed = new Extent();
        $extentFixed->pointMax = $max;
        $extentFixed->pointMin = $min;
        
        while ($row = pg_fetch_object($result)) {

            $polygons = $this->convertWKTtoPolygons($row->wkt, $extentFixed);

            $multipolygon = new MultiPolygon();
            $multipolygon->polygons = $polygons;
            $listamultipolygons[] = $multipolygon;
        }
        return $listamultipolygons;
    }

    /**
     *
     * @param type $canvasExtent
     * @param type $zoomExtent
     * @return Extent 
     */
    private function convertExtent($canvasExtent, $zoomExtent) {

        if ($zoomExtent != null) { 
            $extent = $zoomExtent;
        } else {
            $extent = $this->getExtent(null);
        }

        $maxPoint = $this->convertCanvasPoint($canvasExtent->pointMax, $extent);        
        $minPoint = $this->convertCanvasPoint($canvasExtent->pointMin, $extent);

        $extent = new Extent();
        $extent->pointMax = $maxPoint;
        $extent->pointMin = $minPoint;
 
        return $extent;
    }
    
    /**
     * Converte ponto do canvas para ponto dos dados
     * @param type $point
     * @param type $extent
     * @return Point 
     */
    private function convertCanvasPoint($point,$extent){

        $dataPoint = new Point();        
        $dataPoint->x = ($point->x / $this->canvasW) * ($extent->pointMax->x - $extent->pointMin->x) + $extent->pointMin->x;
        $dataPoint->y = (($point->y - $this->canvasH) / -$this->canvasH) * ($extent->pointMax->y - $extent->pointMin->y) + $extent->pointMin->y;
        return $dataPoint;
    }
}

?>